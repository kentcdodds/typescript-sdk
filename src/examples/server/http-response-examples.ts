import { McpServer } from '../../server/mcp.js';
import { StreamableHTTPServerTransport } from '../../server/streamableHttp.js';
import { randomUUID } from 'node:crypto';
import { z } from 'zod';

/**
 * Example MCP server demonstrating HTTP response handling capabilities.
 * 
 * This example shows how to throw Response objects from request handlers
 * to send direct HTTP responses with custom status codes, headers, and bodies.
 */

const server = new McpServer({
  name: 'http-response-examples',
  version: '1.0.0'
});

// Example 1: Authorization with 401 Unauthorized
server.registerTool('protected-action', {
  title: 'Protected Action',
  description: 'An action that requires authentication',
  inputSchema: {
    action: z.string().describe('Action to perform')
  }
}, async (args) => {
  // Simulate authentication check
  const isAuthenticated = false; // In real app, check actual auth
  
  if (!isAuthenticated) {
    throw new Response('Unauthorized', {
      status: 401,
      headers: {
        'WWW-Authenticate': 'Bearer realm="example", error="invalid_token", resource_metadata="https://example.com/.well-known/oauth-protected-resource"'
      }
    });
  }
  
  return {
    content: [{ type: 'text', text: `Action ${args.action} completed successfully` }]
  };
});

// Example 2: Authorization with 403 Forbidden (insufficient scope)
server.registerTool('admin-action', {
  title: 'Admin Action',
  description: 'An action that requires admin scope',
  inputSchema: {
    command: z.string().describe('Admin command to execute')
  }
}, async (args) => {
  // Simulate scope check
  const hasAdminScope = false; // In real app, check actual scopes
  
  if (!hasAdminScope) {
    throw new Response('Forbidden', {
      status: 403,
      headers: {
        'WWW-Authenticate': 'Bearer error="insufficient_scope", scope="admin write"'
      }
    });
  }
  
  return {
    content: [{ type: 'text', text: `Admin command ${args.command} executed` }]
  };
});

// Example 3: Custom error page
server.registerTool('error-generator', {
  title: 'Error Generator',
  description: 'Generates custom error pages',
  inputSchema: {
    errorType: z.string().describe('Type of error to generate')
  }
}, async (args) => {
  const errorHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Custom Error - ${args.errorType}</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .error { color: #d32f2f; }
        .details { background: #f5f5f5; padding: 20px; border-radius: 4px; }
      </style>
    </head>
    <body>
      <h1 class="error">Custom Error Page</h1>
      <div class="details">
        <h2>Error Type: ${args.errorType}</h2>
        <p>This is a custom error page generated by the MCP server.</p>
        <p>Timestamp: ${new Date().toISOString()}</p>
      </div>
    </body>
    </html>
  `;
  
  throw new Response(errorHtml, {
    status: 500,
    headers: {
      'Content-Type': 'text/html; charset=utf-8',
      'X-Custom-Header': 'error-details',
      'Cache-Control': 'no-cache, no-store, must-revalidate'
    }
  });
});

// Example 4: Redirect response
server.registerTool('redirect-tool', {
  title: 'Redirect Tool',
  description: 'Redirects to another location',
  inputSchema: {
    url: z.string().url().describe('URL to redirect to')
  }
}, async (args) => {
  throw new Response('', {
    status: 302,
    headers: {
      'Location': args.url,
      'Cache-Control': 'no-cache'
    }
  });
});

// Example 5: Successful response with custom headers
server.registerTool('api-response', {
  title: 'API Response',
  description: 'Returns a successful API response with custom headers',
  inputSchema: {
    data: z.string().describe('Data to return')
  }
}, async (args) => {
  const responseData = {
    success: true,
    data: args.data,
    timestamp: Date.now(),
    version: '1.0.0'
  };
  
  throw new Response(JSON.stringify(responseData, null, 2), {
    status: 200,
    headers: {
      'Content-Type': 'application/json; charset=utf-8',
      'X-API-Version': '1.0.0',
      'X-Response-Time': Date.now().toString(),
      'Cache-Control': 'public, max-age=300'
    }
  });
});

// Example 6: Rate limiting response
server.registerTool('rate-limited-action', {
  title: 'Rate Limited Action',
  description: 'An action with rate limiting',
  inputSchema: {
    action: z.string().describe('Action to perform')
  }
}, async (args) => {
  // Simulate rate limit check
  const isRateLimited = true; // In real app, check actual rate limits
  
  if (isRateLimited) {
    throw new Response('Too Many Requests', {
      status: 429,
      headers: {
        'Retry-After': '60',
        'X-RateLimit-Limit': '100',
        'X-RateLimit-Remaining': '0',
        'X-RateLimit-Reset': (Date.now() + 60000).toString()
      }
    });
  }
  
  return {
    content: [{ type: 'text', text: `Action ${args.action} completed` }]
  };
});

// Example 7: Multiple headers with same name (Set-Cookie)
server.registerTool('set-cookies', {
  title: 'Set Cookies',
  description: 'Sets multiple cookies',
  inputSchema: {
    sessionId: z.string().describe('Session ID to set')
  }
}, async (args) => {
  const response = new Response('Cookies set successfully', {
    status: 200,
    headers: {
      'Content-Type': 'text/plain'
    }
  });
  
  // Set multiple cookies
  response.headers.set('Set-Cookie', `sessionId=${args.sessionId}; Path=/; HttpOnly; Secure`);
  response.headers.append('Set-Cookie', 'preferences=dark-mode; Path=/; Max-Age=86400');
  response.headers.append('Set-Cookie', 'analytics=enabled; Path=/; Max-Age=31536000');
  
  throw response;
});

// Example 8: Resource handler with authorization
server.resource('protected-data', 'Protected data resource', async (uri, extra) => {
  // Simulate resource access check
  const hasAccess = false; // In real app, check actual permissions
  
  if (!hasAccess) {
    throw new Response('Resource access denied', {
      status: 403,
      headers: {
        'WWW-Authenticate': 'Bearer error="insufficient_scope", scope="data:read"'
      }
    });
  }
  
  return {
    contents: [{
      uri: uri.toString(),
      mimeType: 'application/json',
      text: JSON.stringify({ data: 'protected content' })
    }]
  };
});

// Example 9: Prompt handler with authorization
server.prompt('admin-prompt', 'Administrative prompt', async (extra) => {
  // Simulate admin check
  const isAdmin = false; // In real app, check actual admin status
  
  if (!isAdmin) {
    throw new Response('Admin access required', {
      status: 401,
      headers: {
        'WWW-Authenticate': 'Bearer realm="admin", error="insufficient_privileges"'
      }
    });
  }
  
  return {
    messages: [{
      role: 'user',
      content: {
        type: 'text',
        text: 'You are an administrative assistant. How can I help you?'
      }
    }]
  };
});

// Example 10: Conditional response based on request headers
server.registerTool('conditional-response', {
  title: 'Conditional Response',
  description: 'Returns different responses based on request headers',
  inputSchema: {
    format: z.string().describe('Response format (json, xml, html)')
  }
}, async (args, extra) => {
  const userAgent = extra.requestInfo?.headers?.['user-agent'] || '';
  const acceptsJson = userAgent.includes('application/json');
  
  if (args.format === 'json' && acceptsJson) {
    throw new Response(JSON.stringify({ 
      message: 'JSON response', 
      userAgent,
      timestamp: Date.now() 
    }), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'X-Response-Format': 'json'
      }
    });
  } else if (args.format === 'html') {
    throw new Response(`
      <html>
        <body>
          <h1>HTML Response</h1>
          <p>User Agent: ${userAgent}</p>
          <p>Timestamp: ${new Date().toISOString()}</p>
        </body>
      </html>
    `, {
      status: 200,
      headers: {
        'Content-Type': 'text/html',
        'X-Response-Format': 'html'
      }
    });
  } else {
    throw new Response('Unsupported format', {
      status: 400,
      headers: {
        'Content-Type': 'text/plain',
        'X-Supported-Formats': 'json, html'
      }
    });
  }
});

export { server };

// Example usage:
// const transport = new StreamableHTTPServerTransport({
//   sessionIdGenerator: () => randomUUID(),
//   enableJsonResponse: false
// });
// 
// await server.connect(transport);
// 
// // The server is now ready to handle HTTP requests with custom responses
